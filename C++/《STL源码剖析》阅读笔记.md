**注：此书使用的STL以及C++版本过早，因此阅读时对代码未有过多阅读或者细究，主要是看STL设计的思路结构**

### 第二章：空间配置器

- 析构是一件花时间的事情，C++中一般会通过type traits对类型做判断，决定是否调用析构处理函数，一般POD型就无需处理。

- 其中的 allocate 内存空间分配器设计值得参考

  - allocate是分配空间，硬盘、内存等存储介质都可以（这里有个疑问，怎么将内存空间的访问和硬盘空间的访问操作等同？还是说特化处理？）

  - 分一、二级

    - 一级主管大空间的申请管理

    - 二级主管小空间的申请，这里是<=128bytes的空间申请。

      内存池做为二级分配器的整块空间池。然后其维护了多个链表，例如链表0维护了数个空间大小为8bytes的小空闲空间，链表1是16bytes，以此类推，以8为倍数。这里可以看出，二级分配器会自动把非8倍数的小空间申请，上调至8的倍数。

      当链表中的空间不足时，会去向内存池申请一定数量的内存，内存池会尽可能返回满足申请要求的空间大小。

      当内存池不足时，首先会像heap空间申请，若申请不到，则从满足空间大小的其余链表中取出一个空闲块返回给需要的链表。如若还无法申请到，则会调用一级配置器（有更好的处理机制？）

      这里有个有意思的操作，<u>每个链表节点其实就是完整的数据空间，指向下一个数据块的指针，存在自身的空间中，而不是另开空间。</u>

    - 自己瞎写：~~这玩意儿似乎有个小bug，就是使用时间长了，容易造成链表中的节点向小空间倾斜？~~  ~~还有就是，小空间的数据使用被释放后，是否还会归还到二级分配器中？~~答：没必要，归还会导致链表膨胀。 

      有了，小bug！每次内存池空间不足时，会把零头分给适当链表，然后向heap申请，这个零头吧，要是每次都落在一个链表上，就有问题了，这里是真膨胀了。

- 有几个全局的未初始化空间初始化函数，它们的特点就是对POD型数据类型、char\*、wchar_t\*特化处理，提高处理效率。同时，有一个准则要注意，就是若初始化空间中的一个元素失败，所有已经初始化好的空间需要回撤，也就是要析构。 要么全部初始化好，要么全没好。

### 第三章 迭代器概念与traits编程技法

- 这里有个不错的思想，如果将迭代器作为脱离于类型的设计，会发现对于不同的数据结构其需要将自己的很多信息暴露给迭代器，也就是说对指定数据结构的迭代器来说，本身需要知道许多关于该数据结构的实现细节信息。因此，迭代器应该是交由数据结构容器的实现者来实现，而非作为一个独立设计。

- ？？？iterator_traits\<T\>::difference_type 不是很懂源码的意思？？？

- 小技巧：函数得形参不写参数名也是可以的，在利用模板实现编译期if-else语法时就很好用

- iterator_traits中有个消除函数单纯传递调用的小思想，可以参考借鉴一下，举例代码如下：

  ```C++
  struct typeA {};
  struct typeB : public typeA{};
  void func(typeA& a);
  void func(typeB& b) { 
  	func(typeA(b));     //单纯的传递调用
  }
  
  template<class T>
  void func(T t, typeA)   //可以解决
  {
      cout << "hello" << endl;
  }
  //注意：这个例子主要还是传递一个思想，例子本身似乎不合理
  ```

- 通过iterator_traits、types_traits本质上是类型的标签，可以在编译期利用模板编程的特性提高代码效率，简化代码。

- 本章看完没有特别大感触？？？ 可能是《Effective C++》后面几章关于模板的讲解涵盖了其中的内容，一些模板技巧已经比较深入的思考过？利用type_traits优化初始化函数的思想也与第二章重叠，或者说进行了完善说明。

- 

