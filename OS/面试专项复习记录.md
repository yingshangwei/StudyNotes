- 进程和线程的区别
  - 八股么就是进程是OS的资源管理单位，线程是OS的调度单位；进程切换开销比线程切换大很多（值得深思？夸cpu的线程切换开销？）；进程创建/撤销的开销比线程的大；同一进程内的线程可以访问进程的几乎所有资源，而OS中的进程相对独立隔离。
  - 进程英文是 process ，线程英文是 thread，感觉process就表示了一个程序的概念，也就是一开始process就是资源和执行合体，后来有人发现可以将执行状态（表述OK？执行序中的指针？指针移动表示程序推进？）和资源分离出来，就有了thread的概念。
- 协程和线程
  - 协程可以理解为语言级的线程，编程语言所提供的线程机制。把线程当成cpu，把协程当成线程就很好理解了。
  - 协程是非抢占式的，需要对应的协程自己放弃当前的运行状态，说实话，其实本质还是是程序员自己安排程序的执行顺序，即对自己知道的耗时操作或者阻塞操作进行整体分摊（当然也可以避免等待IO的时间浪费）。
  - 用任务队列的形式就能实现一个比较建议的协程机制？
- 
- 
- 
- 
- 
- 线程的创建销毁开销？
- cpu cache中存的应该是物理地址对应的值吧？
- linux线程进程的区别？用户级线程和内核级线程？
  - 进程切换流程，主要开销？
    - 切换页表，不确定是不是要先切到一个全局得页表，在切到目标进程得页表
    - 切换内核堆栈：这个内核堆栈是替换的还是并排放在内核区，只要修改堆栈指针状态（相关寄存器）即可？
    - 切换硬件上下文：也就是切换寄存器中的值
    - 刷新TLB：显然与页表强相关的块表也得刷新
      - TLB的flush也要分情况，例如用户线程切内核线程，由于内核空间是所有线程共享，而内核线程没有用户空间，因此没有必要flush TLB；又例如同一进程的不同线程，也就是 mm_struct 指针值一样，也无需flush。
      - 而对于不同进程的线程切换，也有技术可以缓解TLB 的 flush，即利用asid+va来标识va（原先通过va即可判断tlb是否miss）。但是在多核cpu中，会产生多核tlb中都含有某个进程的va情况，若该进程的va与pa的映射发生改变，就需要将包含此va的所有core的tlb都flush，会造成负担。因此是否选用看linux kernel具体arch的实现。//很有意思，感觉这里可以根据具体业务去定制tlb的flush策略。
      - etc... ref:https://blog.csdn.net/weixin_42641385/article/details/116738053
    - CPU指令流水线刷新？
    - 调度器执行：调度器执行在一个单独的线程上吗？
      - 新加入的进程会引发调度上的负载均衡，这个负载均衡显然也需要花一些时间，因此可能会产生某些进程夸cpu的迁移，那如此的话显然的开销就是cpu cache更新所带来的，即会产生很多cache miss；
  - 用户级线程和内核级线程？
    - 主要的区别就是内核线程不具备用户地址空间，使用前一个用户线程的地址空间？ TODO
    - 内核线程主要干什么？kthreadd内核线程？
  - 多线程？
    - linux本身不区分进程和线程的概念，所有的任务都通过struct task_struct来进行描述。由于不同线程间的区别主要在于使用时候的执行状态以及堆栈信息，而内存资源是共享的，因此只要将其内存资源描述符 struct mm_struct *mm 指针指向同一地方即可实现多线程概念。
- 进程间通信的消息队列是系统级的？ 因此要注意数据的残留问题？
- 进程通信
  - 共享内存
    - 如果shmget后不shmdt会怎么样？共享内存的维护机制？
  - 管道
    - 基于linux的文件系统，即临时生成文件节点inode，令其指向物理页，然后管道两端的file结构中的inode都指向这个inode就能实现管道。但我们从更底层的情况来看，实际上这一操作还是在 共享内存 。
  - 信号量
  - 
- 临界区是操作系统为进程提供的机制吗？
- 信号量机制的运作方式，比如它和我需要控制的数据是如何建立关系的？
- 银行家算法？
- 进程组概念？
- ”内核通常被迫使用连续的物理内存“ ？
- 