* **vector** 容器调用clear()函数只是清空元素，调整size，但不释放内存

* **匿名函数**也称为lambda表达式，形如 \[capture]\(pareaments)->return_type{body} 。

  其中，

  capture 为形如[p1,p2,&p3,&p4....]的形式，用来解释队外部变量的调用方法：

  ​		[]：表示不能调用任何外部变量

  ​		\[x]：表示用赋值的形式调用变量x

  ​		\[&x]：表示用引用的形式调用变量x

  ​		\[&]：表示对于所有外部变量用引用形式调用

  ​		\[=]：表示对于所有外部变量用赋值形式调用

  ​		\[x,&]：表示赋值形式调用x，其他变量都用引用形式调用

  ​		\[x,=]：表示用赋值形式调用x，其他变量都用赋值形式调用

  ​		其他都可在上面的形式上扩展。

  return_type 为函数返回值的类型，目前使用是可以省去（待仔细验证）

  pareaments 为函数的参数，当return_type省去时，若无参数，则可省去

  body 即为函数体

- **左值和右值** 简单描述一下就是，左值是有一个确定的内存分配的，可以被赋值和引用；而右值无确定的内存分配，不可赋值，也不可被引用。 很形象的右值的例子就是  `int add(int a, int b) {return a+b; }`这个函数的返回值。

  ref :https://blog.csdn.net/xuwqiang1994/article/details/79924310

- **explicit** 关键字，加在类的构造函数前，表示无法隐士的使用该构造函数去转换类型。这里说明一下由构造函数定义的隐士转换，对于一个类的构造函数，假如只有一个无初始值的参数，就可以进行隐士类型转换，例如

  ```c++
  class A {
      A(){};
      A(int a,int b=1) {};
  };
  A tmp = 3; //隐士转换
  A tmp2 = A(3); //显示转换
  ```

  若在构造函数前加上explicit，即`explicit A(int a, int b=1) {}` ，则 `A tmp = 3 `无法使用。

  ref : https://www.cnblogs.com/gklovexixi/p/5622681.html

  ​		https://www.cnblogs.com/winnersun/archive/2011/07/16/2108440.html

- **function类模板** TODO::需再理解....

  ref : https://blog.csdn.net/qq_35721743/article/details/83217416

- **std::bind()** 函数，一般用来实现回调函数和参数的绑定，若绑定的是类中的函数，就要额外绑定一个隐藏的this指针。

- **类中private关键字** 有很多奇妙的用途，比如隐藏构造函数即可实现很简单的单例模式，隐藏拷贝构造函数实现实例的不可复制属性等。 （有新发现了可以再加+++++++

- **静态变量的局部初始化** 多半不是线程安全的，用的时候还是得手动加锁确保线程安全。查资料得知不同得版本得编译器对静态变量的初始化实现不同，为保证代码的可移植性，手动加锁应该是最好的。

  ref : https://eli.thegreenplace.net/2011/08/30/construction-of-function-static-variables-in-c-is-not-thread-safe

  ​		https://www.cnblogs.com/wangshaowei/p/13498412.html

  ​		https://www.cnblogs.com/zxjan/p/3538911.html