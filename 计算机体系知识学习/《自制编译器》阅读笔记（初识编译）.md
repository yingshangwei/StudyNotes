**写在前头**：*读这本书的目的是为了让自己能够简略的知晓编译相关知识，相当于入个门，不求理解有多深，关键是对编译原理相关的知识体系有个大致的框架。（直接看龙书难度还是过大，希望借这本书比较好的搭一个知识框架）*

### 第1章 开始制作编译器

- gcc将hello.c转换为可执行文件的流程，一般的 *编译*  为以下流程的总和，但真正意义上的编译还是指 第二步 的狭义的编译。
  - 1、预处理
  - 2、（狭义的）编译
    
    - 语法分析（这里准确来说应该是要分出一个 *词法分析* ）
    
      - 语法分析简单来说就是将编程语言结构化的过程（一般是结构化成语法树）。
    
        我的理解就是转化分隔符为树中的结构关系，并提取出符号、标识符等。
    
    - 语义分析
    
      - 大概就是分析变量（表达式、一些符号等的）具体属性（局部还是非局部、是否为引用、类型等），然后检查结构化后的流程是否满足当前结构的要求，补充一定流程（如一定的类型转换）。
    
    - 生成中间代码
    
      - 生成中间代码的目的是为了让前后端分离，即前端专注于语言，与机器无关，而后端专注于机器，只关注中间代码和机器代码之间的映射关系。减少了不必要的重复翻译过程。
    
    - 代码生成
    
      - 将中间代码转化为汇编代码
  - 3、汇编
  - 4、链接
- *编译器* 是将语言转化为可执行的形式，而 *解释器* 可以直接运行代码（Python这种就是解释型语言）。

### 第2章 C**♭**和cbc

- 主要是简单说明了一下C**♭**语言相对于C语言来说不同的部分，

  介绍了一下cbc的包结构，几个出入流程函数。

### 第3章 语法分析概要

- 词法分析 大致是将代码中所有的独立的词都分割提取出来，这是理论上此法分析只需要做的。

  完成词法分析任务的模块叫词法分析器或扫描器。词法分析器不仅仅完成分词任务，还有分析词义的任务（单词+种类+语义值）。

  在编程语言处理系统中，将 一个词+它的种类+语义值 统称为 token。

- 介绍JavaCC生成解析器的功能

### 第4章 词法分析

- 讲述了JavaCC词法分析的规则，本质是基于正则表达式提取所有token。

### 第5章 基于JavaCC的解析器的描述

- 讲述了JavaCC的语法描述规则（基于EBNF）。和正则表达式的表示方式类似。
- 语法树的叶子节点可以称之为终端符，非终端符一定位于语法树中的分叉处。

### 第6章 语法分析

- 介绍了在JavaCC中各种基础语法的描述方法。

### 第7章 JavaCC的action和抽象语法树

- 介绍了JavaCC在匹配token过程中时如何使用action进行自定义操作

### 第8章 抽象语法树的生成

- 介绍了JavaCC如何在匹配token过程中返回token对应的Node来构建抽象语法树，相对来说并没有特别难理解的地方，返回token对应的Node即可。

### 第9章 语义分析（1）引用的消解

- 介绍了语义分析的整体内容

  - 变量引用的消解
  - 类型名称的消解
  - 类型定义检查
  - 表达式的有效性检查
  - 静态类型检查

  然后介绍了引用消解和类型名称消解，这部分内容简单理解就是将所有的名称和定义实体关联起来，使得所有的名称都指向各自最近定义域内的同一实体上。

  当然都是基于如何在JavaCC中实现。

### 第10章 语义分析（2） 静态类型检查

- 不得不说这节很有意思的一个小知识，就是在C/C++中，函数名表示函数变量表示函数指针，然后有意思的就来了

  ​	`void func(){};   ==>  func == *func == **func == ***func == ... == &func`

- 本章主要介绍了如何对定义的有效性（这个比较吸引我的是利用有向图来表示定义的依赖关系，从而可以判断出环引用）、表达式的正确性以及静态类型检查（静态类型检查是自底向上的类型检查方式，而类型推导则是自顶向下的方式）的在JavaCC中的实现逻辑。

### 第11章 中间代码的转换

- 中间代码的意义是为了使语言的表现更加抽象？精简逻辑？然后针对不同的优化方向（比如想要优化逻辑结构、优化最后生成机器语言后的代码效率等）生成不同侧重点的中间代码，然后再针对优化。

  感觉中间代码就是抽象了另一端代码需要优化的点所形成的，如果是由被翻译端的代码主导，感觉就是整理逻辑简单过渡了。

  （TODO::感觉表述有些模糊，之后多看些相关书再来补充好了）

- 本章么主要就是讲了在JavaCC中对各种表达式生成中间代码的逻辑。

  瞅了瞅，就是在扁平化代码（不过整体还是树形结构）使得更接近汇编代码的调用逻辑。

- TODO::这章应该还有个左值右值值得关注。

### 第12章 x86架构的概要（PS:浅尝辄止的计组知识）

- 由于要将上述的中间代码转换为机器语言，那么就需要对计算机系统有一定了解才行，本章简要介绍了计算机系统的基本架构：

  - **物理地址和虚拟地址**：对于每一个进程来说，都有自己的一块独立虚拟地址空间，可以理解为一块虚拟的干净的连续的从0开始的地址空间。然后通过中间层，将访问虚拟地址的操作转换为访问实际的物理地址（CPU内部的MMU会将虚拟地址转换为物理地址）。这里还有一些OS中*页*管理的一些知识可以继续学习。

  - **缓存**：由于cpu的处理速度远远快于访问存储器的速度，因此将需要频繁访问的数据存入高速缓存中是一个比较有效的操作，而且一般程序执行时也确实是对一定数据频繁访问（为什么不将存储器都换为高速存储器呢？因为贵啊）。

    ​			由于现在CPU与存储器速度的差异越来越大，因此就产生了多级缓存机制，也就是L1 cache、L2 cache...

  - **32位/64位**：一般的将寄存器大小为32位的CPU称为32位CPU，64位同理。

  - **指令集架构**：简单理解就是CPU所能使用的指令集集合吧，使用相同指令集的CPU就能同样的执行一个程序（照我理解，可能指令的实现不同，但是效果是一样的，也就是说，流程和输出应是一模一样的）。

  - **IA-32的寄存器**：简要描述一下目前熟悉的吧，主要还是可以触类旁通

    - 通用寄存器：其中esp和ebp虽然是通用寄存器，不过用途一般是固定的，esp存的是指向帧栈的栈顶的地址，ebp是帧栈的底的地址。
    - 指令寄存器（eip）：存储下一条需要执行的指令代码的地址。
    - 标志寄存器
    - 浮点数寄存器
    - MMX寄存器

  - **机器栈**：用以存放一些临时数据（或者保存当前其他寄存器的状态？因为可能当前的运算需要使用多个寄存器但当前寄存器存有数据）。机器栈是由多个帧栈所组成的，帧栈可以对应为C语言中一个函数使用的空间。

  - **指令指针**：即指令寄存器，又可以称为程序计数器。

  - **标志寄存器**：当前只会用到*状态标志*。

    - 1、表示运算结果的 *状态标志*
    - 2、用于控制运算的 *控制标志*
    - 3、用于控制计算机整体运行的 *系统标志*

  - **字节序**：对于一个数据，假设为int，用abcdefgh表示其各位字节，在存储地址中，若按从地址0（小地址）开始到n（大地址），按序存储a、b、c...那么称为大端序，这种存储方式和我们日常书写认知的顺序相同比较自然，因此大端也被称为*网络字节序*；反之就是小端序。

  - **对齐**：为了提升数据的读取速率，降低一些错误。一般会要求数据的地址是数据大小的倍数，也就是说，2字节的数据需要放在数值是2得倍数的地址上，4字节的数据需要放在数值是4的倍数的地址上...

    ​			对于结构体来说，就会按照此规则填充一些额外的空间，同时，结构体的总大小也是最长数据成员长度的倍数。



