*注：本书作者是在研究生阶段完成了本书的写作，所以这本书相对于之前所看的其他书，有可能会稚嫩一些，但也正因为这个原因，书中的思路可能也会和当前读研的自己更加贴近，换句话说，可能更容易理解，值得期待。*

### 第1章 温故而知新

- 每一个**进程**可以说是操作系统设计里的一个小工厂吧，用来完成一些工作。（突然没有一个清楚的比喻概念 TODO::2021-8-17::）。

  先随口说说，*进程* 可以说是一个资源集合，*线程* 可以说是一个任务安排表和任务记录表，属于*进程*，CPU中的核呢就是工人（这些工人只会听命行事）。

- 为了有效利用内存，操作系统以页为单位为进程分配内存，其实对于进程来说，可见的是一块连续的地址从0开始的虚拟内存，和物理内存相映射。

  以页为单位分配物理内存，一是能够更好的利用内存碎片，二就是能够在物理内存不足时，更合理的将不常用的数据置入磁盘中（其他大优点现在我也说不出来）。 这页的管理方式和分治的算法有异曲同工之妙啊。

- 线程之间的数据共享性感觉可以类比两个函数，俩函数的共同访问域应该就是俩线程的共享空间了。线程的私有数据只有一个TLS不是很明白是个啥。

- 一般IO密集型线程优先级会高于CPU密集型线程，因为IO密集型线程比较频繁的释放对cpu的占用。

- linux中的fork可以视为创建当前task的一个镜像，但实现方式比较有意思，就是初始的时候当前task和fork出来的task共享同一个内存空间，fork出来的task修改内存中的内容时，才会复制内容到新的内存中，称为**写时复制**。

- 在 过度优化所产生的线程安全问题 这边，值得注意的两点就是

  1. 由于寄存器的访问速度远快于对内存的访问，编译器为了加速对某一个变量的访问，会将其存入寄存器中一段时间，而不是修改完就写入内存。
  2. 编译器或者cpu为了加速程序运行，可能会调换两个不影响指令的顺序。

- TODO::内核线程和用户线程在多对多的情况下是个什么调用形式？内核线程是和用户线程对应后，直接调用，还是需要通过进程内的信息去调用其内线程？

### 第2章 编译和链接

- 本章主要是自上而下的概述了一下build的流程，以及一些上层概念，比较简单，通过《自制编译器》一书已经了解，因此这里不再赘述。

### 第3章 目标文件里有什么

- ELF格式文件将程序的不同数据分段存储(.text、.data、.bss等等)，有一个之前没接触过的原因就是，现代CPU都是设计成指令缓存和数据缓存分离，因此分段的操作有利于提高CPU缓存的命中率，另外原因一个是便于控制各段权限提高程序安全性，另一个则是便于共享代码段。

- 函数和变量统称为 *符号* ，函数名和变量名则是 *符号名* 。

- C++的名称修饰机制（name managling）可以保证不同地方的变量名不会产生符号冲突问题。通过使用 `extern "C"` 修饰定义可以让变量免于C++的名称修饰机制，而使用C的名称->符号方案。 

  这个名称修饰机制感觉就是通过变量的所在空间、参数等做一个hash变换。

- C/C++中的符号有强弱之分，多个在不同文件中重复定义的强符号，在链接时就会报错，而弱符号则不会。对于多个目标文件中的同名定义符号，一般有如下准则（强弱符号都是针对定义）：

  1. 对于多个同名强符号，就会报错；
  2. 一个强符号，多个弱符号，则以强符号为准；
  3. 多个弱符号，则以所占空间最大的定义为准。

  TODO::突然想到，动态链接库若是使用弱符号，然后程序定义强符号进行覆盖，由于动态链接库在内存中共享的机制，那多个程序使用的时候，会发生什么？  是不是动态链接库只会被程序链接而不会链接程序？

- 一般来说，我们程序中的所有符号都是需要被决议的，也就是使用的时候必须是指向某实体的，这可以称为 *强引用* ；与之相对的，自然有 *弱引用* ，通过使用弱引用时，可以使无法决议的（也就是没有定义）的符号值为默认值，一般为0，其和强引用的过程一致，唯一的差别就是不报错了。

  通过弱引用我们可以实现一些对程序运行环境又或者是编译情况的判断（比如有没有链接某个库），来让程序做出应对。

- 很有用的一个小知识，一般程序build完成后，会带有大量的调试用信息，在linux系统中可以使用`$strip 程序名` 指令去去除ELF文件中的调试用信息。

- 本章概述了ELF文件所包含的信息，如果把ELF文件当成一个类的化，就是介绍了ELF文件这个类每个字段的信息。

  可以打个比喻，如果将OS视为一个执行者的话，那么ELF文件就是一个程序的 说明书+数据(可以当作程序的各个零件吧)，然后OS就是照着说明书组装零件，最后使用它。

### 第4章 静态链接

- 