### 第1章 关于对象

- C++中，struct 和 class 在使用上没什么区别，但是从内涵层面（哲学...）讲，struct表示一组结构化的数据，而class怎么表示一个抽象对象，很显然，两者所表示的不是同一东西。

- struct中数据在内存中也是按顺序排布，因此，有一个很有意思的用法，如下：

  ```c++
  struct member {
  	char pc[1];
  };
  strcut member *p = (struct member*)malloc(sizeof(struct member)+string_len);
  //虽然定义的是长度为1的字符数组，但是可以分配更多内存，让它变成一个动态长度的字符数组
  ```

- ~~C++中相同访问域内的数据按照声明顺序排列，在同一块，但是不同访问域的数据顺序则要看编译器。~~

- 如果一块代码无法判断为是表达式还是声明时，会默认将其视为声明，如下：

  ```c++
  int (*pf)(1024); //由于有1024这个整数存在，会被判断为表达式
  int (*pf)();     //这个就只能默认判定为声明
  ```

- 以下内容还无法达到很好的理解：

  ![image-20210630145250307](../datas/images/image-20210630145250307.png)

### 第2章 构造函数语意学

- 如果一个class没有任何的constructor，那么当constructor真正需要被用到的时候，编译器会自动合成这么一个default constructor。

  这里需要关注 “真正需要用到的时候” 这一点，

  - 显然的意思就是，你不使用这个class实例化对象那肯定是用不到，也就没必要构造；
  - 其次，就是数据成员（包括继承而来的）中有default constructor（不管是class作者自己定义还是编译器合成的）或者有虚函数（包括继承而来的）又或是继承串中有虚继承，有上述特性的类在默认构造时需要合成default constructor。而除上述之外的class，显然，没必要用构造函数去初始化（class作者自己都不操作，编译器操作图啥呢？
    - 简单解释一下上述，存在含有default constructor的data member，就需要调用它们的default constructor 函数，就需要安排调用代码，因此需要合成；
    - 而对于有虚函数的类，因为对于实例化的对象，指向虚函数表的指针内容一定要真确，也就是必须被初始化，那么就需要特定代码被调用，因此也会合成一份default constrcutor用来安插初始化vptr的代码；
    - 对于有虚父类的类，其内部也存在着一份维护访问虚父类数据的数据（存在意义和vptr虚函数表指针一样，编译器无法知道实际需要访问的数据的偏移量，只能通过间接方式固定访问方式），因此，同有虚函数的类一样，也需要合成一份default constructor

  为防止在不同编译模块合成出多个default constructor，由编译器合成的default constructor（copy constructor、destructor、assignment copy operator同理）都是以inline方式完成，若函数过于复杂不适合用inline实现，那么就会合成一个explicit non-inline static 实体。（TODO::这里默认使用inline实现会不会造成一定代码膨胀，是不是可以理解为，用户自定义更有优势？）

- 对于class作者已经设定有constructor的情况（不管是不是default constructor），编译器都不会再合成default constructor，而是将需要初始化的数据的初始化代码置于所有的constructor的user-code用户代码的上面，初始化顺序按照data member的定义顺序来。

  这里有一点需要注意，**initialization list**其实目的是为了指定需要初始化的data member的初始化参数，并不会影响初始化顺序。

- 有三种情况会以一个object为另一个object的初值而调用copy constructor，如下：

  ```c++
  class A {...}
  A a;
  A x = a;       					//直接赋值
  void f(A t) { ... }
  f(a);          					//作为函数的实参调用
  A g() { A t; ... ; return t; }  //作为函数的返回值
  ```

  上述情况下对copy constructor的调用，由于编译器的优化，可能会导致临时object的产生或者程序代码的蜕变（或者两者都有）

- 如果不存在default copy constructor，编译器合成的思路同default constructor

  default constructor的不合成的操作时啥也不干，而default copy constructor不合成的操作则是bitwise copy

- 在copy structor中使用memset、memcpy的操作时，一定要注意避免修改vptr，因为vptr的初始化代码会由编译器合成置于user-code上面。

- 小知识：在严谨的C++用词中，“定义”是指“占用内存“的行为

- 将一个object作为一个函数的参数时，编译器可能会又两种策略：

  ```c++
  A a;
  f(a);
  ```

  - 第一种，先生成一个临时object，调用copy constructor以传入实参为初始值，然后再函数内操作这个临时object，这个策略还会改变程序的代码形式，会将                                            									`void f(A a) => void f(A &a)`
  - 第二种，直接拷贝构建，对参数实际在函数栈中的位置直接用实参值拷贝构建

- 函数返回一个object时，有一种策略是，为函数`A f()` 添加额外参数 `void f(A& __result)` 也就是将返回操作用引用的形式顶替，在原来的return前调用copy constructor初始化 __result，并且另原来的return不返回值。

- 若对于所有的 `A f()` 都return一个具名数值，那么对于上一条，编译器可以做这样的优化，代码如下：

  ```c++
  A f() {       //原函数
      A t;
      ... //操作
      return t;
  }
  void f(A& __result) {  //编译器改写后操作
      A t;
      ... //操作
      __result.A::A(t);
      return;
  }
  void f(A& __result) {  //施加NRV优化后，显然，少了一次default constructor
      __result.A::A();
      ... //直接操作__result
      return;
  }
  ```

  这里值得注意的是，由于优化的存在，导致程序的执行逻辑会和自己所设想的不一致，例如这一段代码 `A a = f();` 一般都会认为a是由copy constructor初始化而来，然而NRV优化会将其变成如下代码：

  ```c++
  A a;
  f(a);  //void f(A& __result);
         //显然...这里没了copy constructor操作，假若自定义的copy constructor中有什么
         //必须执行到的关键操作，那么这边就会出现问题了，毕竟你会认为copy constructor调用
         //了
  ```

  (TODO::没搞懂为什么使用NRV优化还需要explicit copy constructor? 很奇怪，明明开启NRV优化后省去了一步copy constructor)

- 使用member initialization list最大的好处就是能省去几步操作，至少不使用initialization list进行初始化操作而使用赋值操作的化，至少会多一个赋值操作的调用，可能还会产生一个临时对象之后再destructor。显然，使用member initialization list效率会更高。（还会避免一些奇怪赋值带来的奇怪问题？）

  这里还是得再强调一下，初始化顺序是按照声明顺序来的，基类在先！

- 小小感悟：真的是十分有意思得一节内容啊，感觉对以后构建对象得操作会有帮助，会思考得更细致，不过感觉这更多还是思路，毕竟各家编译器不一样，而且，随着时代进步也会更加不同，当然，最重要的是举一反三嘛！

### 第3章 Data语意学

- 在早期编译器上，对于类内的函数，若函数定义在变量声明前，则有可能造成函数内访问的数据是全局数据而非类内的数据（同名），似乎是类的完整定义完成是在遇到类定义的右括号？类中数据绑定至类有滞后性。因此现在保留了将类中函数完整定义写在类定义之后的习惯。

  当然，除此之外，不管如何，类内的对数据或是名称的其他声明都应放在类定义的最初，用以屏蔽全局的名称。

- C++类内，同访问度的域内数据是按照声明顺序排列，当然，不是紧凑排列，数据与数据之间可能会穿插着一些空白空间——alignment带来的。

- 小知识：static data member 存放在data segment（TODO::这里对各个数据区域不了解）

- 由于static data member会被统一放在data segment，当不同类定义了同名static data member时候，编译器会暗中对每一个static data member编码，以确保它们的唯一性，当然可以反编码回原状（这手法叫：name-mangling，美丽倒是没感觉出来......）

- 类内的函数其实最后都会被编译器加上额外参数，一个指向本体的指针也就是this指针，类中访问类中元素最后都是通过this指针调用（感觉是一种实现手法，因此还可以有其他实现方式）

- 对于一个虚继承的对象指针，通过它访问类内存在于虚父类中的对象时，实际是在执行时才能确定真正的访问对象（或者说偏移量，这一点和调用虚函数其实很像）

- 将一个对象抽象为一个串行继承的时候，需要注意由于 alignment特性 的存在，可能会导致串行继承的对象所占空间远大于原来普通的对象。这里为什么不去优化alignment呢？主要是因为在继承体系中，要固定指向继承体系指针解析其所指内存的解析方式，毕竟，优化过后，对内存的解读方式就要按优化的来了。

- 虚函数的存在会给类带来额外负担

  - 需要维护一个虚表（当然得看编译器得具体实现）
  - 每一个类对象实例都需要维护一个vptr指向虚表
  - constructor也需要更加复杂用来维护vptr
  - destructor也是（当然这个我不是很明白，感觉最多复杂一些，原文得话不是很理解 TODO::）

- vptr现在一般都是放在类的首端，以前都是放末端，放末端可以让类维持C strcut的访问方式。

  不过vptr放在首端有一个弊端，就是当父类没有虚函数不需要建立虚表，子类有虚函数需要建立虚表，就会有一定额外开销。（？？？编译器需要多加一些判断代码？？？）

- 单一继承的时候，指针的类型转换很简单，指针都是指向同一个内存起始点，但是当多重继承时，由于有多个父类的远古，指向子类的指针转换为指向父类的指针时，需要做一些偏移计算，会有更多消耗。（编译器可以优化，不过仔细想想，这一步的偏移计算无论如何还是需要的吧？所以相对单一继承来说，多重继承指针的转化（还有存取？）会慢一些）

- 对于使用虚拟继承（又或者使用虚函数，也就是使用C++的多态性质），使用者使用到它的时候自然是需要使用到它的多态性质（又或是在空间与效率的平衡上选择了空间更优，不过这不是我接下来想说的并无关系）也就是说，对于使用者来说使用到虚拟继承的时候就是要使用它的多态性质了，因此对于编译器来说，一律按照多态方式解读代码并无太大不妥。原文如下：

  ![image-20210704171144077](../datas/images/image-20210704171144077.png)

- 该章最后一节讲了一个指向Data Members的指针，比较有意思。

  使用形式如下:

  ```c++
  class A {
  public :
      int a;
      int b;
  };
  const A::* p1 = 0;
  const A::* p2 = &A::a;  //值为a在A中的偏移量，也就是0，不过以前的编译器似乎都会对其+1
  						//用以区别与p1的区别，也就是一个是null指针，一个是指向类内头
  						//部元素。
  						//不过试了一下MinGW编译器中的实现方式，是将p1的值设为了ff..f
  						//而p2正常为0
  
  A a;
  a.*p2;                  //调用a的a成员
  ```

  值得一提得是，由于这种方式更间接了，因此存取效率也就更差了...横向比较继承体系得存取效率...

- （TODO::”额外的间接性会降低’把所有的处理都搬移到寄存器中执行‘的优化能力“，对这句话不是很能理解）

- 本章能了解到很多关于类内元素（以及各种继承下）的内存布局，一个就是虚函数，一般编译器都会实现一个虚表，这样就能多一个虚表指针，还有一个就是虚继承，会多一个虚类表指针（试了一下VS确实是这样）或者将虚父类指针放入虚函数表中。对构建类以及使用类的时候，考虑效率方面会有很多帮助。

### 第4章 Function语意学

- 