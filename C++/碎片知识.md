* **vector** 容器调用clear()函数只是清空元素，调整size，但不释放内存

* **匿名函数**也称为lambda表达式，形如 \[capture]\(pareaments)->return_type{body} 。

  其中，

  capture 为形如[p1,p2,&p3,&p4....]的形式，用来解释队外部变量的调用方法：

  ​		[]：表示不能调用任何外部变量

  ​		\[x]：表示用赋值的形式调用变量x

  ​		\[&x]：表示用引用的形式调用变量x

  ​		\[&]：表示对于所有外部变量用引用形式调用

  ​		\[=]：表示对于所有外部变量用赋值形式调用

  ​		\[x,&]：表示赋值形式调用x，其他变量都用引用形式调用

  ​		\[x,=]：表示用赋值形式调用x，其他变量都用赋值形式调用

  ​		其他都可在上面的形式上扩展。

  return_type 为函数返回值的类型，目前使用是可以省去（待仔细验证）

  pareaments 为函数的参数，当return_type省去时，若无参数，则可省去

  body 即为函数体

- **左值和右值** 简单描述一下就是，左值是有一个确定的内存分配的，可以被赋值和引用；而右值无确定的内存分配，不可赋值，也不可被引用。 很形象的右值的例子就是  `int add(int a, int b) {return a+b; }`这个函数的返回值。

  ref :https://blog.csdn.net/xuwqiang1994/article/details/79924310

- **explicit** 关键字，加在类的构造函数前，表示无法隐士的使用该构造函数去转换类型。这里说明一下由构造函数定义的隐士转换，对于一个类的构造函数，假如只有一个无初始值的参数，就可以进行隐士类型转换，例如

  ```c++
  class A {
      A(){};
      A(int a,int b=1) {};
  };
  A tmp = 3; //隐士转换
  A tmp2 = A(3); //显示转换
  ```

  若在构造函数前加上explicit，即`explicit A(int a, int b=1) {}` ，则 `A tmp = 3 `无法使用。

  ref : https://www.cnblogs.com/gklovexixi/p/5622681.html

  ​		https://www.cnblogs.com/winnersun/archive/2011/07/16/2108440.html

- **function类模板** TODO::需再理解....

  ref : https://blog.csdn.net/qq_35721743/article/details/83217416

- **std::bind()** 函数，一般用来实现回调函数和参数的绑定，若绑定的是类中的函数，就要额外绑定一个隐藏的this指针。简单点儿就是将需要传参的函数封装成不需要参数的函数。

- **类中private关键字** 有很多奇妙的用途，比如隐藏构造函数即可实现很简单的单例模式，隐藏拷贝构造函数实现实例的不可复制属性等。 （有新发现了可以再加+++++++

- **静态变量的局部初始化** 多半不是线程安全的，用的时候还是得手动加锁确保线程安全。查资料得知不同得版本得编译器对静态变量的初始化实现不同，为保证代码的可移植性，手动加锁应该是最好的。

  ref : https://eli.thegreenplace.net/2011/08/30/construction-of-function-static-variables-in-c-is-not-thread-safe

  ​		https://www.cnblogs.com/wangshaowei/p/13498412.html

  ​		https://www.cnblogs.com/zxjan/p/3538911.html
  
- **std::make_shared** 直接用std::shared_ptr构造函数初始化的话，会分配两次内存，而直接使用make_shared只分配一次，提高效率。不过可能会导致内存无法及时回收，使用std::make_shared创建的资源若有weak_ptr，及时shared_ptr引用计数为0，weak_ptr也会维持资源的存在，也就是此时weak_ptr的引用计数为0才可释放资源。

  ref : https://www.jianshu.com/p/03eea8262c11
  
- **auto** 使用auto不会影响编译速度（可能还会一定程度上加速），编译器本身就需要跟踪检查每个变量的类型。不过还是尽量少使用，一定程度上影响代码可读性。

  ref : https://www.zhihu.com/question/21064878

- **std::forward（完美转发）** 保持值是左值还是右值的特性，比如右值一般在传参完后在函数中会变成左值，变左值会多增加拷贝操作。

  ref : https://www.cnblogs.com/catch/p/3507883.html

- **C++ RAII 机制** “资源获取即初始”，也就是说，要将资源的生存周期绑定到一个对象上，对象生存周去即资源生存周期，避免资源泄露。

- **异常抛出**

  - 尽量避免在用户输入错误的时候抛出异常，异常处理的代价比较高，如果用户持续输入错误数据，就会增加CPU负载，会有 服务器拒绝攻击 隐患

- **std::shared_ptr** 智能指针，可以不用自己管理资源周期。不过不能滥用，std::shared_ptr的copy有一定代价，会造成性能损失。

- **#pragma once** 加在"xxx.h"头文件中，防止头文件被多重包含

- **nothrow** 加在new后面可以抑制new操作失败后的异常抛出，而返回空指针

- **Thread join()/detach()** join()函数用来阻塞调用线程然后等待子线程结束，<u>用来回收子线程资源？</u>     detach()函数用来讲调用线程和子线程分离，即让子线程不受主线程的控制（脱离父子关系），使用detach()要注意如果它和其它线程有资源共享，就要防止访问被释放资源产生异常的情况。    （注：Thread类析构时若是对象线程处于joinable状态会立刻终止线程，若其任务未执行完毕会出现异常。）

- **常量 “==” 左边** 一个比较好的习惯，可以一定程度上减少少打一个 “=” 带来的运行错误（编译时期就会提示）

- **类中的static元素初始化应放在.cpp中而不是.h中** 由于.h会被包含多次的远古，若是放在多个头文件中就会被初始化多次，这样就会出现问题。
