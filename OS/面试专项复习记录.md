- 进程和线程的区别
  - 八股么就是进程是OS的资源管理单位，线程是OS的调度单位；进程切换开销比线程切换大很多（值得深思？夸cpu的线程切换开销？）；进程创建/撤销的开销比线程的大；同一进程内的线程可以访问进程的几乎所有资源，而OS中的进程相对独立隔离。
  - 进程英文是 process ，线程英文是 thread，感觉process就表示了一个程序的概念，也就是一开始process就是资源和执行合体，后来有人发现可以将执行状态（表述OK？执行序中的指针？指针移动表示程序推进？）和资源分离出来，就有了thread的概念。
- 协程和线程
  - 协程可以理解为语言级的线程，编程语言所提供的线程机制。把线程当成cpu，把协程当成线程就很好理解了。
  - 协程是非抢占式的，需要对应的协程自己放弃当前的运行状态，说实话，其实本质还是是程序员自己安排程序的执行顺序，即对自己知道的耗时操作或者阻塞操作进行整体分摊（当然也可以避免等待IO的时间浪费）。
  - 用任务队列的形式就能实现一个比较建议的协程机制？
- 死锁
  - 死锁预防
    - 死锁环形资源申请是由于资源可链式交替申请导致的，因此，只要组织交替的资源申请，比如我一次就将所需要的资源申请完毕，即可避免环形产生。但显然，一次申请完所有资源，可能导致某些资源很晚才去使用，导致资源的利用率低；而且程序动态执行，也几乎无法知道之后确定会用到的资源，也就导致你需要申请所有的资源，但有些资源在程序执行时可能并没有用到。（牺牲资源的利用率来防止死锁产生，感觉对资源利用率要求不高，但对程序稳定性要求很高的场景可以采用这策略）
    - 死锁的另一原因是形成环形申请后无法释放之前申请的资源，因此让程序申请不到资源的时候，自动的释放之前所占有的资源，即可预防死锁的产生。但仔细想想，很多时候程序要递进的去申请资源，是希望当前把这件事在这个状态下一下子做完，若割裂了这个流程，就无法达到用户的需求，只能重写逻辑，或者说下次再唤醒的时候，重新从第一个资源的获取开始执行。（很吃程序处理逻辑啊）
    - 提前安排好资源的可申请图，即图中不会出现环，就不会产生死锁。简单的思路就是给所有的资源排序，只能从小的往大的资源申请。（很吃资源的依赖关系）
- 
- 
- 
- 
- 线程的创建销毁开销？
- cpu cache中存的应该是物理地址对应的值吧？
- linux线程进程的区别？用户级线程和内核级线程？
  - 进程切换流程，主要开销？
    - 切换页表，不确定是不是要先切到一个全局得页表，在切到目标进程得页表
    - 切换内核堆栈：这个内核堆栈是替换的还是并排放在内核区，只要修改堆栈指针状态（相关寄存器）即可？
    - 切换硬件上下文：也就是切换寄存器中的值
    - 刷新TLB：显然与页表强相关的块表也得刷新
      - TLB的flush也要分情况，例如用户线程切内核线程，由于内核空间是所有线程共享，而内核线程没有用户空间，因此没有必要flush TLB；又例如同一进程的不同线程，也就是 mm_struct 指针值一样，也无需flush。
      - 而对于不同进程的线程切换，也有技术可以缓解TLB 的 flush，即利用asid+va来标识va（原先通过va即可判断tlb是否miss）。但是在多核cpu中，会产生多核tlb中都含有某个进程的va情况，若该进程的va与pa的映射发生改变，就需要将包含此va的所有core的tlb都flush，会造成负担。因此是否选用看linux kernel具体arch的实现。//很有意思，感觉这里可以根据具体业务去定制tlb的flush策略。
      - etc... ref:https://blog.csdn.net/weixin_42641385/article/details/116738053
    - CPU指令流水线刷新？
    - 调度器执行：调度器执行在一个单独的线程上吗？
      - 新加入的进程会引发调度上的负载均衡，这个负载均衡显然也需要花一些时间，因此可能会产生某些进程夸cpu的迁移，那如此的话显然的开销就是cpu cache更新所带来的，即会产生很多cache miss；
  - 用户级线程和内核级线程？
    - 抛砖引玉：ref:https://blog.csdn.net/KUNPLAYBOY/article/details/124697265?spm=1001.2014.3001.5502
    - 主要的区别就是内核线程不具备用户地址空间，使用前一个用户线程的地址空间？ TODO
    - 内核线程主要干什么？kthreadd内核线程？
  - 多线程？
    - linux本身不区分进程和线程的概念，所有的任务都通过struct task_struct来进行描述。由于不同线程间的区别主要在于使用时候的执行状态以及堆栈信息，而内存资源是共享的，因此只要将其内存资源描述符 struct mm_struct *mm 指针指向同一地方即可实现多线程概念。
- 进程间通信的消息队列是系统级的？ 因此要注意数据的残留问题？
- 进程通信
  - 共享内存
    - 如果shmget后不shmdt会怎么样？共享内存的维护机制？
      - shmdt是将共享内存从当前进程的虚拟空间剥离，我的理解就是对共享内存那块虚拟地址做unmap操作；
      - 共享内存若不用shmctl删除，会一直保留在系统中（毕竟是存在全局数组里，且没有智能指针或者动态维护的机制）；
    - 共享内存段描述信息存在全局的数组里（注意这里是段），当进程需要用到指定共享内存时，就会创建一个新的虚拟内存地址段（vm_area_struct结构），令其中信息描述指向指定的全局数组内存中的共享内存段描述信息即可。
    - 这里注意，因为共享内存是段的概念，因此它有单独的缺页异常处理函数，没错，共享内存也并不是申请就分配物理内存页，也通过缺页异常建立映射。
  - 管道
    - 基于linux的文件系统，即临时生成文件节点inode，令其指向物理页，然后管道两端的file结构中的inode都指向这个inode就能实现管道。但我们从更底层的情况来看，实际上这一操作还是在 共享内存 。
  - 信号量
  - 消息队列
    - 相比于共享内存的优势在于提供了自动的消息同步机制，而不用自己去管理
    - 相比于管道中数据为字节流的形式，消息队列可以自定义消息类型（自动序列化反序列化机制）
    - 似乎消息在内核空间，传递/接收消息的时候都要做消息的夸态复制？
- 临界区是操作系统为进程提供的机制吗？
- 信号量机制的运作方式，比如它和我需要控制的数据是如何建立关系的？
- 银行家算法？
- 进程组概念？
- ”内核通常被迫使用连续的物理内存“ ？
- 