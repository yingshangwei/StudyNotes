#### 条款32：确定你的public继承塑膜出is-a关系

- （A public继承 B）  == （A是B） == （A具有B的所有特性和能力）。这一章有一个很有意思的**反直觉例子**，正方形和矩形的关系，在其数学定义上：正方形是矩形。不过在计算机抽象的世界中，正方形不具有矩形所有的能力（其实特性也是，正方形必须四边相等，而矩形可以邻边不相等）。（思考：能力也是特性抽象出来的？）

#### 条款33：避免遮掩继承而来的名称

- 子类中的名称会覆盖父类中的同名名称，特别要注意的就是这里的覆盖是指覆盖所有的同名名称，比如所有的同名重载函数都是会被覆盖掉，其中的函数查找规则可能就是先查名称再查匹配参数。为了可以使用父类中被覆盖掉的函数，可以使用using。
- 当然事实上应该杜绝这种情况，极少数情况下 ChildrenClass is-a 95% FatherClass 才可能会使用这种方式。

#### 条款34：区分接口继承和实现继承

- 纯虚函数、非纯简单虚函数、非虚函数，三种函数所想要告诉子类对待其的态度不同：纯虚函数表示子类继承接口而无实现；非纯虚函数表示子类继承接口且提供一个缺省实现，子类可以覆盖修改；非虚函数表示子类继承接口和实现且不用修改，是所有继承此Base类的不变共性。
- 通过给纯虚函数提供一份定义，可以将非纯虚简单函数的接口和实现分离，即虽然提供了一份缺省实现，但使用的时候需要连接指定 例如Base::cal() 这种方式。

#### 条款35：考虑virtual函数以外的其他选择

- 使用wrapper函数封装流程，wrapper中的模块功能实现函数可以使用virtual函数，即功能的实现方式可以替换，但流程不变。
- virtual的本质是实现动态绑定函数体（？），即功能需要有，但实现功能的方式可以有差异。此时就可以考虑函数指针，它也可以实现这一诉求。函数指针可以使用C++ 的 fuction 类替换，可以有更多的兼容性（函数指针会限制死入参和出参，即用来赋值的函数指针一定要和定义的函数指针完全匹配）。
- Strategy模式？

#### 条款36：绝不重新定义继承而来的non-virtual函数

- 通过条款34可以明白，定义non-virtual函数是为了体现出事物的不变性，而virtual函数则是表述了事物的特异性，若重新定义non-virtual函数则说明了其特异性，和non-virtual函数定义的本意冲突，显然不合理。

#### 条款37：绝不重新定义继承而来的缺省参数值

- 这个条款最关键的一点就是，对于虚函数来说，函数头是静态绑定的，而函数体是动态绑定的。静态绑定只和发起调用的对象类型有关，而动态绑定则和发起调用的对象指向的实际对象的类型有关。函数头中带着缺省值，所以就很容易理解其中道理。

  ```
  Shape* ps;                       //静态类型为Shape
  Shape* pc = new Circle();   	 //静态类型为Shape，动态类型为Circle
  Shape* pr = new Rectangle();     //静态类型为Shape，动态类型为Rectangle
  ```

- 可以通过定义wrapper函数的方式传递默认参数值

#### 条款38：通过复合塑膜出has-a或“根据某物实现出”

```c++
class Person {
public:
	Date birthDay;
}
class SetInt {
private:
    list<int> container;
}
```

- has-a ：上述代码中的Person::birthDay，表示Person有出生日期这个属性，是固有的，依附于类本身。
- is-implemented-in-terms-of：上述代码中的SetInt::container，是用来实现SetInt类能力的容器，它的存在依附于能力，也就说不存在这种能力的话，其存在就没有意义。
- ？？？感觉理解不是很透彻啊？？？

#### 条款39：明智而审慎地使用private继承

- private继承的显然意义就是同 条款38 中的 “根据某物实现出”相同，那为什么要使用private继承而非复合呢，只有当需要修改其中的虚函数时才会考虑使用private。                                                         这里还有一个极端情况会考虑，就是当你需要复合的对象中没有non-static数据、virtual函数、virtual base classes时，使用private继承在空间上会优于复合的写法。如下：

```c++
class Empty {};             // sizeof(Empty)== 1
							// 对于empty类 C++ 默认插一个char
class A : private Empty {
public :
    int x;
};                          // sizeof(A)    == 4
class B {
public :
    int x;
private :
    Empty empty;
};                          // sizeof(B)    == 8
							// 内存对齐使得 4+1==5 补齐至 8
```

- private继承可以修改虚函数的优势可以通过定义其他的类来继承实现，然后原对象可以继续复合新的对象，这样做其实更易于理解，而且可以降低编译依存性，显然private继承的编译依存性远大于通过指针指向复合对象。（提高编译效率）

#### 条款40：明智而审慎地使用多重继承

- 其实在我个人理解下，多重继承的基础应该是基类间没有交集，至少在数据上互相独立。
- C++ 检查函数是否可用的流程是先检查函数名能不能完全匹配（包括是否有多个同名函数），然后再判断其权限，即函数是否可被访问。
- ？？？virtual base classes  一点儿也不懂，学学？？？
- virtual 继承会增加程序的负担，包括运行时间和空间。
- 多重继承在数据+接口的情况下最为合适。
- ？？？这一节感觉有些迷幻，有些云？？？
- 不过最重要的一点，**明智而审慎地使用**，其实上面两个条款也一样，每一个结构设计出来都是给人用的，只要你能明确地知道为什么要用它，且清楚地知道它有什么样地缺点，并且知道怎么避免缺点带来地问题或者是解决它，那就放心用。

#### 条款41：了解隐式接口和编译期多态

- 对于调用普通类的接口是显示的，模板中调用typename对象的接口是隐式的可以这样理解：对于调用一个已知的类的接口来说，是类有什么接口，我们才能调用什么接口，我们可以显示看见类的接口，因此为显示；而对于模板中调用typename对象的接口是隐式的是因为，对于模板来说并不知道typename对象有什么接口，只是固定的调用一些接口，也就是说，此时是typename对象中的接口需要反过来满足模板的调用，因此可以说接口是隐式的。
- 编译期多态：对于模板来说，调用的typename T的接口取决于传入的T中接口的实现，传入的T不同，调用的接口大多数情况也是不同的。因此需要在编译器具现化模板，使得编译器可以判断当前调用是否合理。

#### 条款42：了解typename的双重意义

- 在template声明式中使用typename和class是一样的，没有什么不同

- typename可以用来声明表达式为类型，如下：

  ```c++
  template<typename T>
  class A : public T {
  public :
  	void test() {
  		typename T::iterator* it;  //若不加typename去说明它是个类型，对于编译器来说
  								   //不知道T::iterator是什么，因为其可能是个变量。
  								   //编译器会默认它不是个类型。（对于嵌套从属名称来								   //说,依赖于T，嵌套于T）
  	}
  };
  ```

- 在继承类的列表中和初始化列表中不允许加typename

#### 条款43：学习处理模板化基类内的名称

- 按照我的理解，对于模板类，若是继承了于模板参数（typename T）有关的对象，那么对于该模板类，是无法直接调用typename T中的对象的。编译器默认屏蔽继承自模板参数依赖对象的接口。若想调用那些接口 :

  ​	1、使用this->掉用（？？？其实没明白去掉this和加上this的区别，可能在编译器内部所查找的域不同？？？）

  ​	2、使用using T::xxxx 将T中的对象名称引入到当前域中  

  ​	3、使用 T::xxxx 调用，直接指定调用域，不过此时存在的问题就是会屏蔽掉virtual动态绑定的功能，也就是让本域中的virtual xxxx函数失去原本设定的用途。

- 上述是编译模板类时会引发的问题。

#### 条款44：将与参数无关的代码抽离

- 对于模板 template 来说，对于每个不同的模板参数会生成不同的代码文件，也就是使用不同的模板参数具现化模板越多，生成的程序体积越大（代码膨胀），可以理解为编译器生成了多个类的代码。对于参数无关的函数或者功能，可以通过复合或者继承的方式将代码抽离出来，防止因参数造成的代码膨胀落到这些参数无关的函数上。

#### 条款45：运用成员函数模板接受所有兼容类型

- 本质也就是说，当你想要让一个函数或者操作兼容数个类型的时候，考虑使用模板来实现这个兼容规则。																																					本节书中举的是智能指针的例子，有继承关系的指针是可以互相转换的，但是当进入智能指针模板后，就被隐藏了这一特性，需要重新描述拷贝构造函数和赋值函数，实现底层指针的转化。这时候就需要用到模板函数。
- 将参数类型转化放入初始化列表中就可以通过编译器判断当前进行转化的类型是否支持隐式转化。
- 模板copy构造函数并不会影响编译器默认生成一组copy构造函数，同理，其他例如赋值操作函数也是如此。

#### 条款46：需要类型转换时请为模板定义非成员函数

- 同条款24，例如对操作函数 * 来说，类型转换是单向的。有class A，可以隐式转换int为class A，对于A\*2来说，2可以隐式转换为A，而对于2\*A来说，A不可隐式转换为int因此会出错。若此时有A operator* (const A& a, const A& b); 那么2*A就不会出错了。（？？？感觉这里有一些编译器匹配函数的规则？？？值得深入学习！）
- 对于模板类来说，若定义 A\<T\> operator* (const  A\<T\>& a, const A\<T\>& b) ，会发现连2*A依然会出现问题。这里问题在于：对于上述非模板函数，函数本身已经存在，因此可以通过2\*A这个表达式去匹配出适配的operator\*函数，但是对于此时的模板函数来说，需要用到的operator\*函数本身并没有具现化，它的具现化依赖于实参，而此时实参需要依赖于函数进行隐式转化，因此会出现问题（感觉这里最关键的应该是模板函数具现化需要完美匹配的参数？？？这是第一步）。
- 对于上述一条，若将模板函数变成friend函数然后置于模板类内部，那就可以解决上面这一问题，因为当类A\<T\>具现化的时候，friend模板函数也被具现化出来，此时函数存在了，就回归到开头的描述了。

#### 条款47：请使用traits classes表现类型信息

- 可以在自定义类型中加一些描述（重定义类名 : typedef 特征类名 通用名读取名），然后通过模板的形式获取其类型特征信息（在编译期）

- 对于内置类型，例如指针，我们可以通过偏特化的形式另模板可以获取其信息。如下：

  ```c++
  template<class T>
  class A<T*> {...}    //此时对于内置指针类型就会使用此版本
  ```

- 通过使用模板函数，可以在编译期达成形如 if...else... 的操作，提高程序运行期的效率（？？？还有执行程序大小？？？）。

#### 条款48：认识template元编程

- 利用template在编译期的很多特性，可以将许多运行期的任务通过template挪到编译期，一定程度上提高程序运行期的效率，使用得当还可以减少程序文件大小。

- 利用template的特性可以在编译器检测变量是否使用正确，这应该很显然。

- 利用TMP（template metaprogramming 模板元编程），可以完成让用户 ”可以定制化使用某一模式“ 这一需求（感觉template 的本意中也包括了这一能力叙述？）

- 感觉这一节最开眼界的就是，通过template具现化这一规则，可以在编译期实现递归甚至循环这中功能，有种打开新世界大门的感觉，代码如下：

  ```C++
  template<int n>
  struct F {
  	enum { value = F<n-1>::value };
  };
  template<>
  struct F<0> {
  	enum { value = 1 };  //偏特化使得上述迭代拥有终止条件
  }
  cout << F<5>::value << endl;   //输出 120
  							   //利用模板具现化的特性实现了编译期阶乘的功能
  							   //？？？这里还利用了enum的特性，初始化和常量性质？？？
  ```

#### 条款49：了解new-handler的行为

- 可以通过重写类的new操作符，利用set_new_haandler函数设置在new操作时会进行的操作。感觉像是C++提供了一套自己的new异常处理框架，用户可以自行定制。（自己通过一些判断信息也是可以实现这种机制带来的效果的）

- 给new设置 std:nothrow可以让new操作失败时不抛出异常而返回0，当然，这无法阻止new后的对象构造函数初始化中没有设置std::nothrow的new操作抛出异常。 所以，使用std::nothrow依然需要你明智而审慎的使用，毕竟很多时候直接返回一个nullptr指针操作起来方便得多。

- 这一节可能最有意思的一个知识就是 "怪异的循环目标那模式"（curiously recurring template pattern；CRTP），代码如下：

  ```c++
  template<class T>
  class A {...};
  class B : public A<B> {...};  //CRTP：在本节主要是为了让A中的静态成员针对继承A的不同							   //类有不同的版本。   其他功效值得学习。
  ```

#### 条款50：了解new和delete得合理替换时机

- 这一节主要罗列了一些重新构造new/delete机制得一些原因。默认的new/delete遵循中庸之道，若是想针对特定的系统提高代码效率以及安全性亦或是实现一些定制功能，那么重构new/delete得机制是值得考虑得。
- 感觉很多思想可以借鉴操作系统对内存的管理？？？ 操作系统yyds
- 重构new/delete，事实上是在针对当前系统完善C++的内存管理机制。

#### 条款51：编写new和delete时需固守常规

- C++规定即使申请0内存也要返回1byte内存的指针（这里可能和上面中的一个条款中说明的C++会给空类也分配一个char大小的空间的知识点呼应，可惜忘了那一个条款）

- 由于继承的存在，父类中重写的new也会被子类所继承，子类使用父类的new会出现许多问题，一个可行的方法是在父类中使用sizeof判断当前申请的空间大小是否和父类一致，不一致就调用普通的new处理。

  注：new 的源码中无调用构造函数的代码，简单查了下资料说是编译器自动插入代码。可以继续了解一下。

- 在Base Class中重载 new[ ] 的时候，要注意不能使用传入的size去计算数组元素个数，在函数中唯一要做的事情就是直接分配size大小的内存块。一是sizeof(Base Class) <= sizeof(Derived Class)，二则是传入的size中可能包含额外的空间用来记录数组元素个数，而并非都是给数组元素。

- delete函数接收到null指针的时候应是啥也不做。

#### 条款52：写了 placement new 也要写 placement delete（TODO：修改，理解可能有问题）

- 简单说重写的new和重写的delete应该要成对存在，尤其是包含额外参数的时候。 如果自定义new中包含额外参数，而未给出包含同样额外参数的delete函数，就会出现内存泄漏的问题。如下形式：

  ```C++
  Class A {
  	static void* new(std::size_t size,std::ostream& logStream) throw(std::bad_alloc);
  };
  A* ptr = new A;         // 若A new失败抛出异常，C++系统会调用与new配对的delete自行
  						// 归还内存，但此时new已经被重写，C++系统找不到配对的delete，
  						// 就会造成内存泄漏
  ```

- 牢记条款33中的名称遮掩问题，在这里你重写new操作函数会造成掩盖父类的new函数名称，导致一些默认的new函数无法使用而产生问题。

#### 条款53：不要轻忽编译器的警告

- virtual void f(); 和virtual void f() const; 是重载关系而非覆盖关系，这一点就导致了以下情况：

  ```C++
  class A {
  public:
  	virtual void f() const;
  };
  class B:public A {
  public:
  	virtual void f();     // 这里的B中的f对于A中的f来说，并不是虚函数的重定义，而只是
                            // 单纯的名称遮掩关系，这一点很重要（虽然并不知道会产生什么样
      					  // 的错误
  };
  ```

- 只有在对编译器发出的警告又深刻认知的情况下，才可以选择无视其警告，例如上述条例子。

- 编译器只是选择它想告知的内容进行提示，不同的编译器所选择的内容不尽相同，因此不能过度依赖编译器，本质还是得编写程序者对自己编写得代码有深刻的认知。

#### 条款54：让自己熟悉包括TR1在内的标准程序库

#### 条款55：让自己熟悉Boost

