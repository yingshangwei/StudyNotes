*注：本书作者是在研究生阶段完成了本书的写作，所以这本书相对于之前所看的其他书，有可能会稚嫩一些，但也正因为这个原因，书中的思路可能也会和当前读研的自己更加贴近，换句话说，可能更容易理解，值得期待。*

### 第1章 温故而知新

- 每一个**进程**可以说是操作系统设计里的一个小工厂吧，用来完成一些工作。（突然没有一个清楚的比喻概念 TODO::2021-8-17::）。

  先随口说说，*进程* 可以说是一个资源集合，*线程* 可以说是一个任务安排表和任务记录表，属于*进程*，CPU中的核呢就是工人（这些工人只会听命行事）。

- 为了有效利用内存，操作系统以页为单位为进程分配内存，其实对于进程来说，可见的是一块连续的地址从0开始的虚拟内存，和物理内存相映射。

  以页为单位分配物理内存，一是能够更好的利用内存碎片，二就是能够在物理内存不足时，更合理的将不常用的数据置入磁盘中（其他大优点现在我也说不出来）。 这页的管理方式和分治的算法有异曲同工之妙啊。

- 线程之间的数据共享性感觉可以类比两个函数，俩函数的共同访问域应该就是俩线程的共享空间了。线程的私有数据只有一个TLS不是很明白是个啥。

- 一般IO密集型线程优先级会高于CPU密集型线程，因为IO密集型线程比较频繁的释放对cpu的占用。

- linux中的fork可以视为创建当前task的一个镜像，但实现方式比较有意思，就是初始的时候当前task和fork出来的task共享同一个内存空间，fork出来的task修改内存中的内容时，才会复制内容到新的内存中，称为**写时复制**。

- 在 过度优化所产生的线程安全问题 这边，值得注意的两点就是

  1. 由于寄存器的访问速度远快于对内存的访问，编译器为了加速对某一个变量的访问，会将其存入寄存器中一段时间，而不是修改完就写入内存。
  2. 编译器或者cpu为了加速程序运行，可能会调换两个不影响指令的顺序。

- TODO::内核线程和用户线程在多对多的情况下是个什么调用形式？内核线程是和用户线程对应后，直接调用，还是需要通过进程内的信息去调用其内线程？

### 第2章 编译和链接

- 本章主要是自上而下的概述了一下build的流程，以及一些上层概念，比较简单，通过《自制编译器》一书已经了解，因此这里不再赘述。

### 第3章 目标文件里有什么

- ELF格式文件将程序的不同数据分段存储(.text、.data、.bss等等)，有一个之前没接触过的原因就是，现代CPU都是设计成指令缓存和数据缓存分离，因此分段的操作有利于提高CPU缓存的命中率，另外原因一个是便于控制各段权限提高程序安全性，另一个则是便于共享代码段。

- 函数和变量统称为 *符号* ，函数名和变量名则是 *符号名* 。

- C++的名称修饰机制（name managling）可以保证不同地方的变量名不会产生符号冲突问题。通过使用 `extern "C"` 修饰定义可以让变量免于C++的名称修饰机制，而使用C的名称->符号方案。 

  这个名称修饰机制感觉就是通过变量的所在空间、参数等做一个hash变换。

- C/C++中的符号有强弱之分，多个在不同文件中重复定义的强符号，在链接时就会报错，而弱符号则不会。对于多个目标文件中的同名定义符号，一般有如下准则（强弱符号都是针对定义）：

  1. 对于多个同名强符号，就会报错；
  2. 一个强符号，多个弱符号，则以强符号为准；
  3. 多个弱符号，则以所占空间最大的定义为准。

  TODO::突然想到，动态链接库若是使用弱符号，然后程序定义强符号进行覆盖，由于动态链接库在内存中共享的机制，那多个程序使用的时候，会发生什么？  是不是动态链接库只会被程序链接而不会链接程序？

- 一般来说，我们程序中的所有符号都是需要被决议的，也就是使用的时候必须是指向某实体的，这可以称为 *强引用* ；与之相对的，自然有 *弱引用* ，通过使用弱引用时，可以使无法决议的（也就是没有定义）的符号值为默认值，一般为0，其和强引用的过程一致，唯一的差别就是不报错了。

  通过弱引用我们可以实现一些对程序运行环境又或者是编译情况的判断（比如有没有链接某个库），来让程序做出应对。

- 很有用的一个小知识，一般程序build完成后，会带有大量的调试用信息，在linux系统中可以使用`$strip 程序名` 指令去去除ELF文件中的调试用信息。

- 本章概述了ELF文件所包含的信息，如果把ELF文件当成一个类的化，就是介绍了ELF文件这个类每个字段的信息。

  可以打个比喻，如果将OS视为一个执行者的话，那么ELF文件就是一个程序的 说明书+数据(可以当作程序的各个零件吧)，然后OS就是照着说明书组装零件，最后使用它。

### 第4章 静态链接

- 为了提高CPU的缓存命中率，一般来说将多个目标文件链接到一起时会将相同段合并到同一段，而不是多个文件的所有段累加上去（那样相同属性的段会零散的分散在内存各处，由于段按照内存页对齐的机制存在，还会导致大量的间隙，产生大量内部内存碎片）。

  想来，假若代码段和数据段夹杂着零散分布，会给重定位也带来一定负担，同一在一个段更利于管理和访问。

- 链接可以分为两个阶段

  1. 为多个目标文件合并安排空间布局。
  2. 消解符号和重定位

  这里可以多描述一下，符号消解在我的理解下就是将当前的符号（虚有其表，类似于指针）和它的本体关联起来（实质的东西，类似于有具体空间的变量实体），而重定位则是将这种关联转换成一种特定的访问方式（或许更正确的应该是字面意思，重新定位该符号实体所对应的具体位置？）。

- ELF文件中的符号表中存了当前目标文件所用到的所有符号的索引信息（指向符号对应的实体），当然对于一些符号来说可能本文件中不存在其定义实体。

  对于目标文件，其中表明符号有没有定义的字段中，还有一个比较特殊的信息是 \*COM\* ，它表明当前符号是个弱符号，也就是说，这个符号的大小还未确定，且当前只存在于符号表中。当链接多个目标文件生成可执行文件时，对于多个 \*COM\* 类型的同名符号，会取其中size最大的符号，将其置入 .bss 段中。 当然，若是和强符号同名，那就保存强符号的信息。

- 这里还发现一个有意思的地方，就是结构体的声明、函数声明其实并不会在汇编代码中留下痕迹，也就是这些声明，想必只有在语义分析那会儿有点儿用。 换句话说，任何声明却无定义的符号，在最后的可执行程序中不会留下任何代码痕迹。

- 现在GCC编译器对于模板函数等在不同的编译单元（目标文件）中会生成相同代码的问题，一般是通过将这些生成函数置入单独的段中，在合并时取其一（当然有可能相同函数所生成的代码不同，加了编译优化参数或者使用了不同的编译器版本），这样就能避免相同代码带来的程序膨胀。虚函数表、默认构造函数等差不多都是以类似的方法解决。

  仔细想想，在不同的目标文件中生成同样的代码这一过程，本身就是个问题，上面的解决方案可以说治标不治本。这种重复生成代码的过程会降低编译效率。

  开开脑洞，能否抑制编译的生成函数代码阶段至链接时呢？

- 一般链接时都会把所有目标文件合并，但事实上，对于程序的执行流来说，所用到的变量、函数可能并不包括所有目标文件中的变量、符号，理论上来说，只需要合并程序执行流所依赖的所有符号即可。 

  函数级别链接 就是将所有的函数分段保存，链接时只链接执行所依赖的函数，虽然增加了编译负担，但是一定程度上较小了程序的体积 （感觉这里应该是要取平衡，因为程序体积也有可能变大？）。

- *ABI* 在我的理解下，就是在二进制级别下的一些约定，比如内存对齐规则、帧栈中的数据存储规则、符号的解析规则等等。

- *静态库* 本质上就是多个目标文件的集合（目标文件是书的话，静态库就是图书馆了，方便查找），一般这些目标文件都是以函数为单位的，目的就是为了链接的时候能够最大程度上减少所链接的内容，减小程序体积。

- 可以通过链接控制脚本控制目标文件链接时候的规则，比如空间布局、段的合并、段的删除等，能够让最后的程序满足一些特定的空间需求（尤其在一些特定的硬件上）。

- BFD 库可以解析ELF文件，一般build流程中需要读取ELF文件信息的地方都是利用了BFD库。

  想要自制调试器的话这玩意儿应该很好用。

- 本章主要是概述了静态链接的流程，然后简要介绍了流程中关键的一些步骤，包括空间地址分配、符号消解和重定位、重复代码的消除方案、弱符号大小不确定的解决方案，顺便讲解了一下怎么自定义链接流程。感觉是介绍一下静态链接过程中比较重要的几个点，只是浅尝，并未太深入。

### 第5章 Window PE/COFF

- 略

### 第6章 可执行文件的装载与进程

- 我所设想的是，OS在装载程序的时候，不会完全将程序内容放入内存，只有在需要的时候才会从硬盘中将内容装入内存中。

  因此，程序实际上在运行的时候，如果删去源文件，就会出问题。因此在Windows上，程序运行时删除程序的操作，是不被允许的；而在linux中，可以rm在运行中的程序，我猜测是因为和linux中的rm并非是真正删除硬盘中的内容有关，而缺页错误所访问的内容地址，是真正的硬盘地址，而非通过linux的文件系统（瞎猜，TODO::）

- 对于操作系统的进程来说，它所管理的虚拟内存空间中，虚拟内存页有三种状态：

  1. 已分配物理内存页，但当前处于被置入磁盘的状态；
  2. 已分配物理内存页，且当前就存在于内存中；
  3. 未分配物理内存页。

  为了一定程度上提高操作系统的效率，操作系统一般都是先建立虚拟内存和物理内存的映射，然后延迟置入真正的内存中，也就是只有真正需要访问数据的时候，才会真正置入物理内存页中。

  进程初始时就是状态3，*装载程序* 事实上是在将其转入状态1，即建立虚拟内存页和磁盘上的程序文件的映射。

- 由上可以提到一个mmap函数，该函数的行为就是在建立虚拟内存和磁盘的映射，也就是生成状态1。

  使用malloc动态分配内存时，小的空间请求是通过brk来实现（移动数据段后的brk指针来来分配），大的空间请求则是通过mmap建立虚拟内存页和磁盘的映射来实现（感觉这是在形容没有已分配的虚拟页能够塞下新的空间请求的时候是通过mmap来实现的，大多数情况下应该只是在已分配的页中寻找空余空间），这里的mmap建立的映射似乎是称为匿名映射，似乎是建立了一个和内存和磁盘swap区域上的一个映射。

- 对于装载这一个步骤来说，一般是一个段分配一个内存页，如果段很多，就会造成很多的内存间隙。因此，一般在生成可执行文件时，都会将目标文件中访问权限相同的节合并，这样就可以大大减少对内存页的需求。

  同时，为了进一步减少空间浪费，操作系统可能还会将同一个内存页映射给两个不同的虚拟页，这个虚拟页中会同时存在两个不同段的内容。这也是消除两个段之间间隙的一种手段。

  TODO::不过这里我有个疑问，为什么不都直接通过第二种方式映射？会有什么问题？是会有更多的性能负担吗？

- 本章主要是介绍了一个程序是如何置入进程中的，进程中的虚拟内存空间和物理内存空间的映射关系。程序装载实际上就是在建立虚拟空间和磁盘文件数据的映射。后面还说了一些消除内存页间间隙的一些机制。

### 第7章 动态链接

- 



