#### 条款32：确定你的public继承塑膜出is-a关系

- （A public继承 B）  == （A是B） == （A具有B的所有特性和能力）。这一章有一个很有意思的**反直觉例子**，正方形和矩形的关系，在其数学定义上：正方形是矩形。不过在计算机抽象的世界中，正方形不具有矩形所有的能力（其实特性也是，正方形必须四边相等，而矩形可以邻边不相等）。（思考：能力也是特性抽象出来的？）

#### 条款33：避免遮掩继承而来的名称

- 子类中的名称会覆盖父类中的同名名称，特别要注意的就是这里的覆盖是指覆盖所有的同名名称，比如所有的同名重载函数都是会被覆盖掉，其中的函数查找规则可能就是先查名称再查匹配参数。为了可以使用父类中被覆盖掉的函数，可以使用using。
- 当然事实上应该杜绝这种情况，极少数情况下 ChildrenClass is-a 95% FatherClass 才可能会使用这种方式。

#### 条款34：区分接口继承和实现继承

- 纯虚函数、非纯简单虚函数、非虚函数，三种函数所想要告诉子类对待其的态度不同：纯虚函数表示子类继承接口而无实现；非纯虚函数表示子类继承接口且提供一个缺省实现，子类可以覆盖修改；非虚函数表示子类继承接口和实现且不用修改，是所有继承此Base类的不变共性。
- 通过给纯虚函数提供一份定义，可以将非纯虚简单函数的接口和实现分离，即虽然提供了一份缺省实现，但使用的时候需要连接指定 例如Base::cal() 这种方式。

#### 条款35：考虑virtual函数以外的其他选择

- 使用wrapper函数封装流程，wrapper中的模块功能实现函数可以使用virtual函数，即功能的实现方式可以替换，但流程不变。
- virtual的本质是实现动态绑定函数体（？），即功能需要有，但实现功能的方式可以有差异。此时就可以考虑函数指针，它也可以实现这一诉求。函数指针可以使用C++ 的 fuction 类替换，可以有更多的兼容性（函数指针会限制死入参和出参，即用来赋值的函数指针一定要和定义的函数指针完全匹配）。
- Strategy模式？

#### 条款36：绝不重新定义继承而来的non-virtual函数

- 通过条款34可以明白，定义non-virtual函数是为了体现出事物的不变性，而virtual函数则是表述了事物的特异性，若重新定义non-virtual函数则说明了其特异性，和non-virtual函数定义的本意冲突，显然不合理。

#### 条款37：绝不重新定义继承而来的缺省参数值

- 这个条款最关键的一点就是，对于虚函数来说，函数头是静态绑定的，而函数体是动态绑定的。静态绑定只和发起调用的对象类型有关，而动态绑定则和发起调用的对象指向的实际对象的类型有关。函数头中带着缺省值，所以就很容易理解其中道理。

  ```
  Shape* ps;                       //静态类型为Shape
  Shape* pc = new Circle();   	 //静态类型为Shape，动态类型为Circle
  Shape* pr = new Rectangle();     //静态类型为Shape，动态类型为Rectangle
  ```

- 可以通过定义wrapper函数的方式传递默认参数值

#### 条款38：通过复合塑膜出has-a或“根据某物实现出”

```c++
class Person {
public:
	Date birthDay;
}
class SetInt {
private:
    list<int> container;
}
```

- has-a ：上述代码中的Person::birthDay，表示Person有出生日期这个属性，是固有的，依附于类本身。
- is-implemented-in-terms-of：上述代码中的SetInt::container，是用来实现SetInt类能力的容器，它的存在依附于能力，也就说不存在这种能力的话，其存在就没有意义。
- ？？？感觉理解不是很透彻啊？？？

#### 条款39：明智而审慎地使用private继承

- private继承的显然意义就是同 条款38 中的 “根据某物实现出”相同，那为什么要使用private继承而非复合呢，只有当需要修改其中的虚函数时才会考虑使用private。                                                         这里还有一个极端情况会考虑，就是当你需要复合的对象中没有non-static数据、virtual函数、virtual base classes时，使用private继承在空间上会优于复合的写法。如下：

```c++
class Empty {};             // sizeof(Empty)== 1
							// 对于empty类 C++ 默认插一个char
class A : private Empty {
public :
    int x;
};                          // sizeof(A)    == 4
class B {
public :
    int x;
private :
    Empty empty;
};                          // sizeof(B)    == 8
							// 内存对齐使得 4+1==5 补齐至 8
```

- private继承可以修改虚函数的优势可以通过定义其他的类来继承实现，然后原对象可以继续复合新的对象，这样做其实更易于理解，而且可以降低编译依存性，显然private继承的编译依存性远大于通过指针指向复合对象。（提高编译效率）

#### 条款40：明智而审慎地使用多重继承

- 其实在我个人理解下，多重继承的基础应该是基类间没有交集，至少在数据上互相独立。
- C++ 检查函数是否可用的流程是先检查函数名能不能完全匹配（包括是否有多个同名函数），然后再判断其权限，即函数是否可被访问。
- ？？？virtual base classes  一点儿也不懂，学学？？？
- virtual 继承会增加程序的负担，包括运行时间和空间。
- 多重继承在数据+接口的情况下最为合适。
- ？？？这一节感觉有些迷幻，有些云？？？
- 不过最重要的一点，**明智而审慎地使用**，其实上面两个条款也一样，每一个结构设计出来都是给人用的，只要你能明确地知道为什么要用它，且清楚地知道它有什么样地缺点，并且知道怎么避免缺点带来地问题或者是解决它，那就放心用。

