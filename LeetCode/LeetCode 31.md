思路：从后往前遍历，当前i，如果存在j使得nums[j]>nums[i]，就让nums[j]和nums[k]交换，nums[k]为比nums[i]大的数中最小的数，且k取最大。这时候就要考虑交换后在下标i后面的数需要按从小到大排序，发现在之前从后往前的遍历中，会让i后面的数按从大到小排序，如果不是，那么必有                                			                 nums[p]<nums[q]&&i>p>q，与当前的遍历结果矛盾，因此i后面的数必定是降序排序，那么我们只要反转i后面的序列即可。