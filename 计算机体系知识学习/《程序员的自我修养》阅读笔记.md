*注：本书作者是在研究生阶段完成了本书的写作，所以这本书相对于之前所看的其他书，有可能会稚嫩一些，但也正因为这个原因，书中的思路可能也会和当前读研的自己更加贴近，换句话说，可能更容易理解，值得期待。*

### 第1章 温故而知新

- 每一个**进程**可以说是操作系统设计里的一个小工厂吧，用来完成一些工作。（突然没有一个清楚的比喻概念 TODO::2021-8-17::）。

  先随口说说，*进程* 可以说是一个资源集合，*线程* 可以说是一个任务安排表和任务记录表，属于*进程*，CPU中的核呢就是工人（这些工人只会听命行事）。

- 为了有效利用内存，操作系统以页为单位为进程分配内存，其实对于进程来说，可见的是一块连续的地址从0开始的虚拟内存，和物理内存相映射。

  以页为单位分配物理内存，一是能够更好的利用内存碎片，二就是能够在物理内存不足时，更合理的将不常用的数据置入磁盘中（其他大优点现在我也说不出来）。 这页的管理方式和分治的算法有异曲同工之妙啊。

- 线程之间的数据共享性感觉可以类比两个函数，俩函数的共同访问域应该就是俩线程的共享空间了。线程的私有数据只有一个TLS不是很明白是个啥。

- 一般IO密集型线程优先级会高于CPU密集型线程，因为IO密集型线程比较频繁的释放对cpu的占用。

- linux中的fork可以视为创建当前task的一个镜像，但实现方式比较有意思，就是初始的时候当前task和fork出来的task共享同一个内存空间，fork出来的task修改内存中的内容时，才会复制内容到新的内存中，称为**写时复制**。

- 在 过度优化所产生的线程安全问题 这边，值得注意的两点就是

  1. 由于寄存器的访问速度远快于对内存的访问，编译器为了加速对某一个变量的访问，会将其存入寄存器中一段时间，而不是修改完就写入内存。
  2. 编译器或者cpu为了加速程序运行，可能会调换两个不影响指令的顺序。

- TODO::内核线程和用户线程在多对多的情况下是个什么调用形式？内核线程是和用户线程对应后，直接调用，还是需要通过进程内的信息去调用其内线程？

### 第2章 编译和链接

- 本章主要是自上而下的概述了一下build的流程，以及一些上层概念，比较简单，通过《自制编译器》一书已经了解，因此这里不再赘述。

### 第3章 目标文件里有什么

- 

